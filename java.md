# 如何高效的拷贝数组

使用 `System.arraycopy()` 方法进行数组的拷贝操作。它内部是通过调用 native 方法直接在内存中进行批量拷贝，速度很快。

# 集合

java 集合中的两个顶级接口：Collection 和 Map。继承了 Collection 接口的有 Set, List 和 Queue。Collection 接口定义了一些操作集合的方法，比如对集合的增删改查

# String

String 类不能够被继承，因为 String 类使用了 final 关键进行修饰。并且 String 类它是一个不可变类。不可变类有如下的特点：

- 内部的状态不可修改，所有的属性都被声明成 private final，并且没有对外提供任何修改内部状态的方法。
- 线程安全。根据不可变类的特性，天生就是线程安全的。
- 共享和复用。根据不可变类的特性，它可以被安全的共享和复用, 无需担心其他地方的修改而导致的不一致问题。
- 缓存友好。因为不可变类的对象具有唯一性和不可变性。因此可以通过缓存来提供程序的性能，避免重复的创建对象。

# 静态代理和动态代理

实现静态代理时，代理类需要声明被代理类的所有方法并且内聚一个被代理类。代理对象可以在调用被代理对象的方法前后增加自定义的逻辑，来达到增强的效果，也就是动态代理中的 before 和 after 增强。静态代理的缺点就是：因为静态代理类需要内聚一个被代理类，所以即使 before 或者是 after 的逻辑是一样的，但是只要代理的是不同类型的对象，就需要重新声明一个类，当需要代理的类型很多时，维护代码将变得非常的麻烦。

动态代理则是将变化的那一部分给抽取出来，我们只需要编写 before 和 after 这部分的代码，其余的动作像类的创建以及类的实例化，都由动态代理来完成。


# AOP 和 IOC

AOP(面向切面编程)是一种编程范式。它将跨域多个模块的功能从主业务中抽离出来，从而提高代码的模块化和可重用性。

IOC(控制反转) 是一种设计原则，它负责创建对象以及管理对象的生命周期，开发人员只需要定义对象之间的依赖关系不需要关心对象创建的过程。

从 AOP 和 IOC 的定义和作用来看。 AOP 定义类，而 IOC 则是根据 AOP 的定义创建对应的对象，并将其注入到合适的对象中。

AOP 将横切关注点从主要业务逻辑中分离出来并通过切面来实现横切关注点的功能。而 IOC 则通过依赖注入将切面注入到应用程序中，从而实现横切关注点的功能。

AOP 和 IOC 都是为了提高代码的可重用性，可维护性以及灵活性。

# 类的方法和数据存放在哪个区？

类的方法代码(指令) 和类的数据(静态变量) 都存放在元空间。元空间主要用于存放类的元数据信息，常量池，静态变量，即时编译器生成的代码等。

# 有哪些方式可以获取到类的 class 对象

- `类名.class`
- 实例对象的 `getClass()` 方法
- 使用 `Class.forName()` 方法
- 通过类的 Classloader 的 `loadClass()` 方法

## 哪种方式获取 Class 对象的效率最好

`类名.class` 获取 Class 对象的方式最好，因为这种方式在编译器就已经是确定的了，不需要进行方法的调用和反射。

# 反射创建对象的方式

- 通过 Class 对象的 `newInstance()` 方法
- 获取到 Class 对象的构造函数，在创建对应的对象