# 并发三大特性

- 原子性：指的是多个操作作为一个整体，不可分割，要么全部执行成功，要么全部执行失败。
- 有序性：有序性指的是程序执行的顺序与代码编写的顺序是一致的。
- 可见性: 一个线程对某个变量的修改能够及时的被其他线程所看到的。现代计算机体系结构中，每个线程都有自己的本地缓存， 因此一个线程对共享变量的修改可能不会立即被其他线程看到。

# 数据可见性

所谓的数据可见性是指线程 A 对变量 V 的修改写回到内存之后，线程 B 再读取变量 V 的值。这样变量 V 的最新值才是对线程 B 可见的。 

volatile 关键字将数据写回内存的过程中，会无效化其他处理器内核中的缓存行。这就保证了变量在修改之后，对其他线程或者处理器内核是立即可见。

# 指令重排序

为了性能优化，编译器和处理器会进行指令重排序。指令重排序是指在程序执行期间，编译器或处理器为了优化程序的执行效率，将原本的指令执行顺序进行重新排序的过程。指令重排序只能够重排序内存屏障之前的指令。

指令重排序会遵循 `as-if-seria` 规范。即重排序后，只会提升性能，但是不会影响单线程执行的结果。这个准则在单线程的情况下是没有任何问题的，但是在多线程的情况下，出现指令重排，程序的执行结果可能会和我们的预期不一样。下面举一个例子：

```java
int x = 1
boolean y = false

// Thread 1
void method1() {
	x = 10	
	y = true
}

// Thread 2
void method2() {
	if(y) {
		System.out.println(x)
	}
}
```

没有执行指令优化时，单线程顺序执行 `method1` 和  `method2` 的结果是打印 `10`

当编译器进行指令重排序优化或者是 CPU 进行指令重排序优化时，可能会将 `method1` 重排序成如下的指令顺序:

```java
void method1() {
	y = true
	x = 10
}
```

在发生指令重排序并且是多线程来执行的时候，最终打印的结果可能是：`1` ， 而不是 `10` 了。

由于编译器或者是 CPU 不知道多线程情况下是不能够进行指令重排序的，因此我们需要使用内存屏障明确的告知编译器或者是 CPU 不能够对该变量进行指令重排序。

# 内存屏障

内存屏障(Memory Barrier), 也称为内存栅栏, 用于保证内存操作的可见性和有序性。内存屏障的语义是：内存屏障之前的所有写操作都需要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。

- 写后加写屏障会将高速缓存中的值写回内存
- 读前加读屏障会将高速缓存中的值置为无效状态，进而从内存中读取数据

# volatile 和 synchronized 的区别

volatile 关键字可以保证可见性以及禁止指令重排序，不满足原子性。synchronized 关键字能够满足可见性，有序性以及原子性。

volatile 和 synchronized  都是 java 并发编程中的同步机制，但是它们的作用和应用场景不同。volatile 关键字适用于当多个线程之间需要共享变量但是不需要互斥访问的场景。而 synchronized 关键字适用于多线程之间需要共享变量并且需要互斥访问的场景。

```ad-warning 注意
虽然 synchronized 满足了并发的三大特性，但是它并不能够阻止指令重排序的发生。指令重排序和有序性是两个不同的概念。有序性是指：将 synchornized 关键字所修饰的方法由并发执行改成串行执行，并且它不关心方法内部的指令是否会发生指令重排序。即 synchronized 关键字只负责将多个线程进行排队，一个线程执行完毕之后，切换下一个线程来执行，它不关心这些线程到底如何执行。
```

# 单例模式

```java
public class Singleton {
	private static volatile Singleton instance;

	private Singleton(){}

	public static Singleton getInstance() {
		if(instance == null) {
			synchronized(Singleton.class) {
				if(instance == null) {
					instance = new Singleton();
				}
			}	
		}	
		return instance;
	}
}
```

java 中使用 new 创建对象并不是一个原子指令。它可以分为如下 3 步：

1. 分配内存空间
2. 初始化对象(调用构造函数等)
3. 将变量指向刚刚分配的内存空间

创建对象的第 2 和第 3 步, CPU 可能会进行指令重排序，变成: 

1. 分配内存空间
2. 将变量指向刚刚分配的内存空间
3. 初始化对象(调用构造函数等)

双重校验锁实现单例模式时需要使用 volatile 关键字来保证线程安全，具体原因是：由于 JVM 可能会对指令进行重排，可能导致在某个线程执行到第一次判空检查时，由于指令重排的优化，对象的引用已经被赋值，但对象的构造函数还没有执行。此时，如果有另一个线程执行了判空检查，就会发现对象引用不为空，从而直接返回一个未被完全构造的对象，导致单例模式失效。

# 参考文章

- https://blog.csdn.net/u012988901/article/details/111313057
- https://blog.csdn.net/Hellowenpan/article/details/117750543

# 线程间通信的方式

- 共享内存：多个线程共享一些变量，通过对共享变量的读写实现数据的交换和协调工作。但是在共享变量的时候，需要注意线程间的同步问题保证数据的正确性和一致性。
- 锁机制：线程可以通过锁机制来阻塞其他线程的执行，从而保证数据的正确性和一致性
- 信号量：当信号量的值大于零，线程继续执行操作，小于零时，线程等待

# 进程与线程的区别

- 进程是操作系统分配资源的基本单位，而线程是 CPU 调度的基本单位，线程比进程更轻量
- 同一个进程中的所有线程共享进程所拥有的资源，由于线程之间共享这些资源，需要考虑线程之间的同步问题。
- 进程需要完整的上下文切换，而线程只需要切换程序计数器，栈和少量的寄存器状态