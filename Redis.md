# 缓存问题

##  缓存穿透

缓存穿透指的是用户访问的数据既不在缓存中，也不在数据库中，即一个不存在的数据。由于缓存中不存在对应的数据，所以所有的请求都直接作用在了数据库上，当这种无效请求大量涌入时，数据库的压力骤增，最终可能会导致数据库崩溃。

### 解决方案

1. 限制非法请求
2. 缓存空值或默认值
3. 使用布隆过滤器(Bloom Filter)快速判断数据是否存在，避免通过查询数据库判断数据是否存在

#### 限制非法请求

限制非法请求指的是在 API 入口处对参数进行校验，对于不符合参数要求的请求直接返回错误，避免进一步的访问缓存和数据库

#### 缓存空值或者是默认值

当出现缓存穿透的现象时，可以缓存一些空值或则默认值，这样后续的请求就会访问缓存而不会访问数据库。从而减小数据的压力

**思考**

如果大量的缓存所谓的空值或者是默认值，内存是否会被消耗完？虽然有 LRU 算法，但是当内存使用完以后，redis 缓存数据时需要做一些额外的操作，是否会降低 redis 的执行效率。chatgpt 上回答 redis 是通过后台线程去执行 LRU 算法：

>Redis 中的 LRU 算法是由后台线程来执行的，它会周期性地扫描缓存中的数据，计算缓存中每个数据的访问频率和时效性，根据一定的策略淘汰最近最少使用的数据。在 Redis 中，可以使用 `maxmemory-policy` 配置项来指定 LRU 算法的淘汰策略，常用的策略包括：
>
>- volatile-lru：只对设置了过期时间的键采用 LRU 算法进行淘汰。
>- allkeys-lru：对所有键采用 LRU 算法进行淘汰。
>- volatile-ttl：淘汰过期时间最近的键。
>- noeviction：禁止淘汰数据，当内存不足时，所有写操作将返回错误。

#### 布隆过滤器

布隆过滤器的工作原理是：当我们将数据写入数据库时，使用布隆过滤器做一个标记。如果缓存失效，首先查看布隆过滤器快速判断数据库中是否存在对应的数据，如果不存在，也不需要查询数据库判断对应的数据是否存在。布隆过滤器的工作原理是：如果布隆过滤器查询到数据不存在，那么数据就一定不存在，但是查询到数据存在，数据库中也不一定存在。主要原因是布隆过滤器底层是通过哈希函数实现的，有哈希冲突的情况存在。即存在一个位置对应多个数据的情况。

通过布隆过滤器，可以过滤掉一部分明显不存在的请求，减轻对数据库的压力。

布隆过滤器不能 100% 防止缓存穿透。布隆过滤器是一种基于概率的数据结构，它可以用于判断一个元素是否可能存在于一个集合中，但无法确定一个元素是否一定存在于集合中。

在缓存穿透的情况下，请求查询一个不存在于缓存和数据库中的数据，这个请求会直接访问数据库，导致数据库压力过大。**布隆过滤器可以用于过滤掉一部分明显不存在的请求，以减轻对数据库的压力。**

布隆过滤器的工作原理是通过多个哈希函数将元素映射到一个位数组中，并设置对应的位为1。当一个元素查询时，通过多个哈希函数计算出多个位的位置，如果这些位都为1，则说明元素可能存在于集合中；如果其中有一个位为0，则说明元素一定不存在于集合中。

虽然布隆过滤器可以快速判断一个元素可能不存在于集合中，但由于存在哈希冲突和位数组大小限制等问题，会有一定的误判率。也就是说，布隆过滤器可能会将一个实际上不存在的元素误判为存在。这就意味着，在极端情况下，仍然可能发生缓存穿透的情况。

为了进一步减少缓存穿透的可能性，可以采取其他策略，如在查询数据库之前先进行简单的校验，或者使用互斥锁等方式来避免并发请求同时查询数据库。此外，还可以使用缓存预热、设置合理的过期时间等手段来提高缓存的命中率，减少缓存穿透的概率。

##  缓存雪崩

缓存雪崩是指缓存数据大面积失效，大量的用户请求绕过缓存直接查询数据库，导致数据库压力骤增的一种现象。严重的情况下，这可能导致数据库宕机，并引发一些列的连锁反应，最终导致系统崩溃

### 解决方案

缓存雪崩的原因是在某个时刻大量的缓存数据同时失效，这时有如下的几种解决方案可供选择：

1. 均匀设置过期时间(双 key 策略)
2. 互斥锁
3. 后台更新缓存

#### 均匀设置过期时间

如果需要为缓存数据设置过期时间，应该避免将大量的缓存数据设置成同一个过期时间。为了解决这个问题，可以在设置缓存数据的过期时间时，添加一个随机数。这样可以避免缓存数据在同一时刻同时失效。

双 key 策略和均匀设置过期时间想法是类似，双 key 指的是业务 key 以及随机过期时间 key。查询缓存时，首先查看随机过期时间 key 是否过期，如果过期则说明缓存失效，否则缓存有效。

#### 互斥锁

1. 判断 redis 中是否存在对应的缓存
	1. 如果 redis 中不存在对应的缓存，则发送一条从数据库中加载数据的消息到消息队列
	2. 如果 redis 中存在对应的的缓存，直接返回即可
2. 消费消息队列中的消息，并使用 redis 作为互斥锁，实现消费消息的幂等性
3. 为了防止未获取到缓存直接返回，可以增加一个重试机制，比如每隔 10 ms 检测一次，重复 10 次, 提高缓存的命中率
4. 可以使用 redis 作为互斥锁的原因：redis 操作缓存中的数据是单线程，也就避免了多线程竞争的一个问题，通过 redis 还提供了一些原子指令，比如 setnx，这个指令是使用 redis 实现互斥锁的一个关键指令。setnx 的语义是：如果对应的 key 不存在，则设置对应的值，并返回 1，否则不进行任何的操作，并返回 0。

伪代码实现如下：

```go
func Get(key string) {
	for i := 0; i < 10; i+= {
		value := redis.get(key)
		if value != nil {
			return value	
		}
		rabbitmq.send(message)
		// sleep 10ms
		sleep(10)
	}
	return nil
}

func consume(msg Message) {
	// 这种模式可以考虑使用多线程的方式来消费消息，从而大大提高消费的速度
	// 采用多线程时，不应该使用过多的线程去消费，否则也会导致数据的压力过大，
	// 最终可能导致数据库崩溃
	key := msg.Key()
	lock := key+"lock"
	if redis.setnx(lock) {
		if redis.get(key) == nil {
			// load data from database
			// ......
		}
		// it must be guaranteed that the lock will be released
		// even if an exception occurs.
		defer redis.del(lock)
	}
}
```

如果采用消息队列的方式，则可以认为是后台线程更新缓存(异步)。如果不采用消息队列的方式，则是同步的方式。采用同步的方式的话，只需要将 `consume` 方法中的逻辑移入 Get 方法中即可。

## 缓存击穿

缓存击穿指的是热点数据失效，大量的请求绕过缓存直接查询数据的现象。这种现象和缓存雪崩非常类似或者说缓存击穿是缓存雪崩的一个子集，因此可以使用缓存雪崩的处理方式来处理缓存击穿。

## Redis 宕机

出现 Redis 宕机时，两种方案可供选择：

1. 服务熔断
2. 请求限流

### 服务熔断

如果采用服务熔断的机制，在 Redis 宕机之后，直接暂停应用对缓存数据的访问，直接返回错误，不再访问数据库，从而降低数据库的压力，保证数据库的正常运行。等到 Redis 恢复之后在允许应用访问缓存数据。

虽然服务熔断保证了数据库的正常运行，但是暂停了应用对数据的访问，导致应用无法对外提供服务。

### 请求限流

当 Redis 宕机时，请求限流策略会放行少部分的请求交给数据库处理。如果直接将全部的请求交给数据库处理，会导致数据库压力骤增，可能引发数据库崩溃，进而引发一系列的连锁反应，最终导致系统崩溃。请求限流的方式让应用对外提供有限的服务，相比于请求熔断采用一刀切的方式，请求限流可能是一种更优的选择。

# 集群模式

- 主从复制模式
- 哨兵模式
- Cluster 模式

## 主从复制模式

主从复制模式下，主服务器负责写，从服务器负责读，实现读写分离，在写少读多的情况下，可以大幅度提升服务的并发量

### 缺点

- 主从复制模式下，一旦主节点由于故障不能够提供服务，无法自动进行故障转移，需要手动的将从节点晋升为主节点。同时还要通知客户端更新主节点的地址。
- 主节点无法进行水平扩展，单台主节点的容量和处理写请求能力有限

### 主从模式的配置

主从模式的配置主要是通过 redis 配置文件中的 `slaveof` 选项，如果是主节点，则不需要配置这个选项，如果是从节点，则需要配置这个选项，该选项的参数为主节点的 IP 地址和端口号:

```conf
slaveof 127.0.0.1 6379
```

## 哨兵(sentinel) 模式

哨兵(sentinel) 是运行在特殊模式下的 redis 服务器，不支持读写操作，它的作用是配合 redis 的复制功能，实现对主从节点的监控，对下线的主节点进行故障转移和通知

哨兵模式主要是用来解决主从复制模式下故障无法自动转移的问题的。哨兵是一个单独的进程，它负责监控 redis 和 sentinel 的运行情况

哨兵里面有个一个 quarom 配置，该配置表示需要多少个哨兵同意，才能够执行相应的操作。

### 监听原理

- sentinel 每隔 10s 会向 redis 集群发送 info 命令，获取 redis 集群新的拓扑结构信息，包括主从节点，IP 地址，端口号。当我们动态的添加 redis 节点时，sentinel 就可以通过这种方式获取到 redis 集群最新的拓扑结构。
- sentinel 每隔 2s 向 redis 主节点中的 `__sentinel__:hello`  频道发送消息, 消息的内容包括：主节点信息以及当前哨兵节点的信息。通过这种方式，可以交换哨兵之间关于主节点以及哨兵节点的信息

sentinel 会订阅主节点中的 `__sentinel__:hello` 频道，并将自身的 IP 地址和端口号发布到该频道中。当其他哨兵订阅该频道后，就可以和对应的哨兵建立连接，交换信息，这样哨兵集群就搭建好了。

sentinel 在启动时，需要在配置文件中配置需要监听的 redis 主节点。成功监听 redis 主节点之后，它会给主节点发送 info 命令获取到从库列表，获取到从库列表之后，哨兵会与每个从库建立连接，从而对从库进行监控

### 主库下线

主库下线的状态可以分为主观下线和客观下线：

- 主观下线：当一个哨兵通过健康检测发现主节点下线，此时主库处于主观下线的状态
- 客观下线：哨兵集群投票确定主节点下线，此时主节点处于客观下线的状态。处于该状态后，哨兵集群会自动进行故障转移操作。

具体流程：

1. 当一个哨兵发现主节点下线之后，会发送 `is-master-down-by-addr` 这个命令给其他的哨兵节点。
2. 哨兵节点会根据自身与主节点的连接情况进行投票，如果发现主节点下线，则投赞成票，否则投反对票。最后将赞成票与配置文件中 quorum(法人) 数进行比较，大于等于法人数(quorum)，则表示投票成功，将主节点的状态置为客观下线状态

### 哨兵选举

在主节点客观现在之后，需要有一个哨兵来执行故障转移工作。因此需要在哨兵集群中选举出一个主节点，来实施故障转移的操作。

raft 算法：选票数大于集群节点的一半时，将成为 leader，否则继续选举。

哨兵成为 leader 的条件：

- 获得超过半数以上的投票
- 投票数超过配置文件中的法人数(quorum)

以上的两个条件都需要满足才行

### 新主节点

在将从节点晋升为主节点时，选择哪一个从节点作为主节点，需要遵循如下的几条规则：

1. 过滤掉不健康的从节点，比如 ping 不通或者网络状态不好的节点
2. 选择 `slave-priority` 优先级高的节点
3. 选择复制偏移量最大的从节点

## Cluster 模式

Redis 的 Cluster 模式采用无中心结构，每个节点保存数据以及整个集群的状态，每个节点都和其他节点相连。节点之间使用 [[分布式#Gossip 协议 | Gossip]] 协议传播信息以及发现新的节点。

Redis Cluster 模式将数据分成  $2^{14}=16384$ 个哈希槽(slots), 集群中的每个 redis 实例分摊管理这些槽位，并且每个实例会保存自身管理的槽位信息，每个实例管理的槽位数可以不一样，如性能好的机器可以多管理些槽位。当所有的槽位都有 redis 实例管理时，集群处于 online 状态，否则集群处于 offline 状态。集群中的实例通过 Gossip 协议沟通之后，就可以知晓其他槽位的分配情况。

### 故障转移

Cluster 模式支持主备模式，用于提高系统的容灾能力，并且只有主节点负责读写请求和集群信息的维护；从节点只进行主节点数据和状态信息的复制。

Redis Cluster 可以为主节点设置多个从节点，当某个主节点发生故障时，会自动将某个从节点晋升为主节点；如果某个主节点不存在从节点，那么集群将处于不可用的状态。同时 redis 也提供了 `cluster-require-full-coverage` 参数用于设置当集群部分节点故障时，是否允许集群继续对外提供服务。

集群中的节点通过 `PING/PONG` 的方式进行健康检测。集群中节点的下线需要经历两个过程：主观下线以及客观下线。

主观下线指的是 B 节点在 `cluster-node-timeout` 的时间内未对 A 节点发出的 PING 命令做出响应，则 A 节点主观认为 B 节点下线。但是 B 节点是否客观下线还需要集群中其他的主节点做出投票。当集群中其他的主节点通过 PING 命令发现 B 节点确实下线之后，会投出赞成票。当集群有超过半数的主节点投出赞成票时，B 的状态将会被置为客观下线状态，并进行故障转移。

故障转移就是将某个从节点晋升为主节点的过程。这个过程需要集群中所有持有槽的主节点进行投票选举，选举出一个符合条件的从节点作为主节点。

### hash tag

当一个 key 包含 `{}` 时，redis 将不会对 `key` 进行哈希操作，而是对 `{}` 中包含的内容进行哈希操作。这样就可以让不同的 key 拥有相同的哈希值，从而被分配到同一个哈希槽中，进而支持批量操作(mget/mset), 事务，lua 脚本等。但是 hash tag 可能会出现数据分配不均匀,进而导致请求分配不均匀的问题，针对这些问题我们需要：

1. 调整不同节点中哈希槽的数量
2. 避免对热点数据使用 hash tag

# 参考链接

- https://cloud.tencent.com/developer/article/1605715
- https://www.cnblogs.com/wzh2010/p/15886799.html


